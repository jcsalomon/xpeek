% \iffalse meta-comment
% !TeX program = pdflatex
% !TeX encoding = utf-8
% !TeX spellcheck = en_US
%<*internal>
\iffalse
%</internal>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
xpeek: Define commands that peek ahead in the input stream

Released under the LaTeX Project Public License v1.3c or later;
see ‹http://www.latex-project.org/lppl.txt›.
----------------------------------------------------------------
\endpreamble
\postamble
Copyright © 2012 by Joel C. Salomon ‹joelcsalomon@gmail.com›.

The original code is due to Enrico “egreg” Gregorio, with modifications
according to suggestions by Enrico, Joseph Wright, & Bruno Le Floch.

This work may be distributed and/or modified under the conditions of
the LaTeX Project Public License, either version 1.3 of this license
or (at your option) any later version.

The latest version of this license is at
  ‹http://www.latex-project.org/lppl.txt›.

This work is “maintained” (per LPPL maintenance status) by
Joel C. Salomon ‹joelcsalomon@gmail.com›.

This work consists of the file  xpeek.dtx,
          and the derived files xpeek.ins,
                                xpeek.pdf, &
                                xpeek.sty.
\endpostamble
\usedir{tex/latex/xpeek}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/xpeek}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{xpeek}
\usepackage[utf8]{inputenc}
\usepackage{framed}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \changes{Version 1.0}{2012/07/17}{Initial version}
% \changes{Version 1.1}{2012/07/18}{Add hooks}
%
% \GetFileInfo{\jobname.sty}
%
% \DoNotIndex{\NewDocumentCommand,\RequirePackage}
% \DoNotIndex{\ProvidesExplPackage}
% \DoNotIndex{\bool_if:NTF,\bool_if:nTF,\bool_new:N}
% \DoNotIndex{\bool_set_false:N,\bool_set_true:N}
% \DoNotIndex{\c_space_token}
% \DoNotIndex{\cs_new_protected:Npn,\cs_new_protected_nopar:Npn}
% \DoNotIndex{\cs_if_exist:cT,\cs_to_str:N}
% \DoNotIndex{\msg_error:nnnn,\msg_new:nnn,\msg_new:nnnn}
% \DoNotIndex{\peek_catcode_ignore_spaces:NF}
% \DoNotIndex{\tl_gput_right:cn,\tl_gremove_all:cn}
% \DoNotIndex{\tl_if_exist:cF,\tl_if_single_token_p:n}
% \DoNotIndex{\tl_map_break:,\tl_map_inline:cn,\tl_map_inline:nn}
% \DoNotIndex{\tl_new:c}
% \DoNotIndex{\token_if_cs_p:N,\token_if_eq_charcode:NNT}
% \DoNotIndex{\token_to_str:N}
% \DoNotIndex{\use:c}
%
% \title{^^A
%   The \pkg{\jobname} package^^A
%     \thanks{^^A
%       This file describes release \fileversion,
%       last revised \filedate.^^A
%     }^^A
% }
% \author{^^A
%   Joel C. Salomon\\
%   ‹\href{mailto:joelcsalomon@gmail.com}{joelcsalomon@gmail.com}›^^A
%   \thanks
%     {The original code is due to Enrico \enquote{egreg} Gregorio,
%       based on an answer he gave to a question of mine on
%         \href{http://tex.stackexchange.com}{\TeX.SX};
%       see ‹\href{http://tex.stackexchange.com/a/59542/2966}
%         {http://tex.stackexchange.com/a/59542/2966}›.
%       Enrico, Joseph Wright, \& Bruno Le Floch helped
%       iron out the implementation;
%       Bruno also wrote the initial version of the documentation.
%       See ‹\href{http://tex.stackexchange.com/q/63568/2966}
%         {http://tex.stackexchange.com/q/63568/2966}›.}^^A
% }
% \date{Released \filedate}
%
% \maketitle
%
% \begin{abstract}
%   The \pkg{\jobname} package defines \cs{NewPeekCommand}.
%   Commands generated by this macro behave like the familiar \cs{xspace}:
%   they peek ahead at what comes after them in the input stream,
%   compare this against a list of \emph{exceptions},
%   and choose what to do depending on whether there was a match.
% \end{abstract}
%
% \tableofcontents
%
% \begin{documentation}
% \section{Basic Usage}
%
% The \pkg{\jobname} package provides functions
% to define and manage commands
% which can peek ahead into the input stream.
%
% For a simple usage example,
% consider the following (admittedly silly) code:
% \begin{quote}
%   |\NewPeekCommand{\xpeek}| \\
%   |  {(always)}{(followed)}{(not followed)}| \\
%   |\AddToPeekExceptions{\xpeek}{x}| \\
%   |\newcommand{\foo}{foo\xpeek}| \\
%   |\foo \foo x|
% \end{quote}
% When executed, the code above yields this output:
% \begin{quote}
%   \NewPeekCommand{\xpeek}
%     {(always)}{(followed)}{(not followed)}
%   \AddToPeekExceptions{\xpeek}{x}
%   \newcommand{\foo}{foo\xpeek}
%   \foo \foo x
% \end{quote}
% The first |\foo| is followed (skipping spaces)
% by the second |\foo|,
% and so the first and third options
% — |(always)| \& |(not followed)| —
% are selected.
% The second |\foo| is followed by the token |x|,
% so the first and second options
% — |(always)| \& |(followed)| —
% are selected.
%
% \section{User commands}
%
% The following user-level commands are defined:
%
% \begin{function}{\NewPeekCommand}
%   \begin{syntax}
%     \cs{NewPeekCommand} \marg{function} \marg{always} \marg{followed} \marg{not followed}
%   \end{syntax}
%   Defines the \meta{function} as a new \enquote{peek} command,
%   one which looks at the following token.
%   If this token is part of the exception list
%   (see \cs{AddToPeekExceptions}),
%   use the \meta{always} and \meta{followed} tokens;
%   otherwise use the \meta{always} and \meta{not followed} tokens.
% \end{function}
%
% \begin{function}{\AddToPeekExceptions}
%   \begin{syntax}
%     \cs{AddToPeekExceptions} \marg{function} \marg{exceptions}
%   \end{syntax}
%   Adds every token in the \meta{exceptions}
%   to the exception list for the \meta{function}.
% \end{function}
%
% \begin{function}{\RemoveFromPeekExceptions}
%   \begin{syntax}
%     \cs{RemoveFromPeekExceptions} \marg{function} \marg{exceptions}
%   \end{syntax}
%   Removes every token in the \meta{exceptions}
%   from the exception list for the \meta{function}.
% \end{function}
%
% \section{Hooks}
%
% For when the basic \meta{always}\meta{followed}/\meta{not followed}
% functionality is insufficient,
% \pkg{\jobname} provides the ability to hook into the execution.
%
% \begin{function}{\NPC_xpeek_hook:}
%   \begin{syntax}
%     \cs{cs_new_protected:Npn} \cs{NPC_xpeek_hook:} \marg{hook}
%   \end{syntax}
%   This command
%   (actually \cs{NPC_\meta{function}_hook:})
%   is \emph{not} defined by \pkg{\jobname},
%   but can optionally be defined by the user.
%   If defined, it executes after \meta{followed}/\meta{not followed}
%   and has access to the token stream following the command.
% \end{function}
%
%   To illustrate, add a hook to the silly example from above:
%   \begin{quote}
%     |\NewPeekCommand{\xpeek}| \\
%     |  {(always)}{(followed)}{(not followed)}| \\
%     |\AddToPeekExceptions{\xpeek}{x}| \\
%     |\newcommand{\foo}{foo\xpeek}| \\
%     |\foo y \foo x\\| \\
%     |\ExplSyntaxNamesOn| \\
%     |\cs_new_protected:Npn \NPC_xpeek_hook:| \\
%     |  {(next is \exp_not:N \l_peek_token)}| \\
%     |\ExplSyntaxNamesOff| \\
%     |\foo y \foo x|
%   \end{quote}
%   This will yield
%   \begin{quote}
%     \newcommand{\foo}{foo\xpeek}
%     \foo y \foo x\\
%     \ExplSyntaxNamesOn
%     \cs_new_protected:Npn \NPC_xpeek_hook:
%       {(next is \exp_not:N \l_peek_token)}
%     \ExplSyntaxNamesOff
%     \foo y \foo x
%   \end{quote}
%   with the hook’s effect visible in the second line.
%
%   This functionality is occasionally useful.

%   For example,
%   consider a simple analogue to \LaTeX’s \cs{textit} command,
%   which intelligently inserts italic correction only when needed,
%   \textit{i.e.}, when not followed by low-height punctuation.
%   The font-change must be surrounded by
%   \cs{group_begin:}/\cs{group_end:},
%   but the italic correction (if present)
%   must lie within the group.
%   \begin{quote}
%     |\ExplSyntaxNamesOn| \\
%     |\NewDocumentCommand{\xit}{m}| \\
%     |  {\group_begin:\itshape#1\__xit_cor}| \\
%     |\NewPeekCommand{\__xit_cor}{}{}{\/}| \\
%     |\AddToPeekExceptions{\__xit_cor}{.,}| \\
%     |\cs_new_protected:Npn \NPC___xit_cor_hook: {\group_end:}| \\
%     |\ExplSyntaxNamesOff| \\
%     |\xit{f},\quad\xit{f}.\quad\xit{f};\quad\xit{f}!|
%   \end{quote}
%   This yields
%   \begin{quote}
%     \ExplSyntaxNamesOn
%     \NewDocumentCommand{\xit}{m}
%       {\group_begin:\itshape#1\__xit_cor}
%     \NewPeekCommand{\__xit_cor}{}{}{\/}
%     \AddToPeekExceptions{\__xit_cor}{.,}
%     \cs_new_protected:Npn \NPC___xit_cor_hook: {\group_end:}
%     \ExplSyntaxNamesOff
%     \xit{f},\quad\xit{f}.\quad\xit{f};\quad\xit{f}!
%   \end{quote}
%   with the italic corrections correctly applied.
%
%   The \pkg{xspace} package provides similar functionality.
%   Its manual suggests using hooks for
%   when further scanning of the input stream is necessary.
%   (It gives an example of such a case.)
%   I don’t know how to achieve such scan-ahead,
%   but I’m open to suggestions.
%
% \end{documentation}
%
% \section{Internal commands}
%
% \begin{function}{\NPC_new_peek_command:Nnnn}
%   \begin{syntax}
%     \cs{NPC_new_peek_command:Nnnn} \meta{function} \marg{always} \marg{followed} \marg{not followed}
%   \end{syntax}
%   Defines \meta{function} as a new peek command.
%   This is the internal version of \cs{NewPeekCommand};
%   see above.
% \end{function}
%
% \begin{function}{\NPC_add_to_peek_exceptions:Nn}
%   \begin{syntax}
%     \cs{NPC_add_to_peek_exceptions:Nn} \meta{function} \marg{exceptions}
%   \end{syntax}
%   Adds every token in \meta{exceptions}
%   to the exception list for \meta{function}.
%   This is the internal version of \cs{AddToPeekExceptions};
%   see above.

% \end{function}
%
% \begin{function}{\NPC_remove_from_peek_exceptions:Nn}
%   \begin{syntax}
%     \cs{NPC_remove_from_peek_exceptions:Nn} \meta{function} \marg{exceptions}
%   \end{syntax}
%   Removes every token in \meta{exceptions}
%   from the exception list for \meta{function}.
%   This is the internal version of \cs{RemoveFromPeekExceptions};
%   see above.
% \end{function}
%
% \begin{implementation}
% \section{\pkg{\jobname} Implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Load \pkg{xparse}
% and enable \texttt{expl} syntax for this package.
%    \begin{macrocode}
\RequirePackage{expl3,xparse}
\ProvidesExplPackage
  {xpeek} {2012/07/18} {1.1}
  {Define commands that peek ahead in the input stream}
%    \end{macrocode}
%
% \subsection{User commands}
%
% The user-level commands
% call internal functions for their actual implementations.
%
% \begin{macro}{\NewPeekCommand}
%   Hand-off to \cs{NPC_new_peek_command:Nnnn}.
%    \begin{macrocode}
\NewDocumentCommand { \NewPeekCommand } {m m m m}
  {
    \NPC_new_peek_command:Nnnn #1 {#2} {#3} {#4}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AddToPeekExceptions}
%   Hand-off to \cs{NPC_add_to_peek_exceptions:Nn}.
%    \begin{macrocode}
\NewDocumentCommand { \AddToPeekExceptions } { m m }
  {
    \NPC_add_to_peek_exceptions:Nn #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\RemoveFromPeekExceptions}
%   Hand-off to \cs{NPC_remove_from_peek_exceptions:Nn}.
%    \begin{macrocode}
\NewDocumentCommand { \RemoveFromPeekExceptions } { m m }
  {
    \NPC_remove_from_peek_exceptions:Nn #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
% \begin{macro}[internal]{cs-expected}
% Used when the first argument of one of the user functions
% is not a single control sequence:
%    \begin{macrocode}
\msg_new:nnnn { NPC } { cs-expected }
  { The~first~argument~of~#1 must~be~a~control~sequence. }
  {
    The~command~#1 received~'#2'~as~its~first~argument,
    ~instead~of~a~single~control~sequence
    ~such~as~\token_to_str:N \xspace.
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{undeclared-peek-command}
% Used when the first argument of
% \cs{AddToPeekExceptions} or \cs{RemoveFromPeekExceptions}
% is an unknown control sequence:
%    \begin{macrocode}
\msg_new:nnn { NPC } { undeclared-peek-command }
  {
    The~first~argument~of~#1 must~be~declared~with~
    \token_to_str:N \NewPeekCommand.
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Internal commands}
%
% These commands all check their arguments for errors,
% then call low-level functions for their actual implementations.
%
% \begin{macro}{\NPC_new_peek_command:Nnnn}
%   Check that |#1| is a single control sequence;
%   that is,
%   check that |#1| is a token list with exactly one token,
%   then check that this token is a control sequence.
%   (The test will fail if |#1| is a single space, but who cares?)
%
%   If the input is correct (|T| branch),
%   call \cs{__NPC_new_peek_command:Nnnn};
%   otherwise raise an error and do nothing.
%    \begin{macrocode}
\cs_new_protected:Npn \NPC_new_peek_command:Nnnn #1#2#3#4
  {
    \bool_if:nTF { \tl_if_single_token_p:n {#1} && \token_if_cs_p:N {#1} }
      { \__NPC_new_peek_command:Nnnn #1 {#2} {#3} {#4} }
      { \msg_error:nnnn
          { NPC } { cs-expected } { \NPC_new_peek_command:Nnnn } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NPC_add_to_peek_exceptions:Nn}
%   Check (as above) that |#1| is a single control sequence;
%   otherwise, raise an error.
%
%   Next, check that the exception list exists,
%   \textit{i.e.},
%   that the command |#1| was declared
%   with \cs{NPC_new_peek_command:Nnnn}.
%   If the input was correct, call \cs{__NPC_add_to_peek_exceptions:Nn}.
%    \begin{macrocode}
\cs_new_protected:Npn \NPC_add_to_peek_exceptions:Nn #1#2
  {
    \bool_if:nTF
      { \tl_if_single_token_p:n {#1} && \token_if_cs_p:N {#1} }
      {
        \tl_if_exist:cF { g_ \cs_to_str:N #1 _exceptions_tl }
          { \msg_error:nnnn
              { NPC } { undeclared-peek-command }
              { \NPC_add_to_peek_exceptions:Nn } {#1}
            \tl_new:c { g_ \cs_to_str:N #1 _exceptions_tl }
          }
        \__NPC_add_to_peek_exceptions:Nn #1 {#2}
      }
      { \msg_error:nnnn
          { NPC } { cs-expected } { \NPC_new_peek_command:Nnnn } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NPC_remove_from_peek_exceptions:Nn}
%   Check for errors just as \cs{NPC_add_to_peek_exceptions:Nn} does,
%   then call \cs{__NPC_remove_from_peek_exceptions:Nn}.
%    \begin{macrocode}
\cs_new_protected:Npn \NPC_remove_from_peek_exceptions:Nn #1#2
  {
    \bool_if:nTF
      { \tl_if_single_token_p:n {#1} && \token_if_cs_p:N {#1} }
      {
        \tl_if_exist:cF { g_ \cs_to_str:N #1 _exceptions_tl }
          { \msg_error:nnnn
              { NPC } { undeclared-peek-command }
              { \AddToPeekExceptions } {#1}
            \tl_new:c { g_ \cs_to_str:N #1 _exceptions_tl }
          }
        \__NPC_remove_from_peek_exceptions:Nn #1 {#2}
      }
      { \msg_error:nnnn
          { NPC } { cs-expected } { \NPC_new_peek_command:Nnnn } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Low-level commands}
%
% These commands actually implement the package’s functionality.
%
% \begin{macro}[internal]{\__NPC_add_to_peek_exceptions:Nn}
%   Add all the tokens in |#2|
%   to the list of exceptions for the peek command |#1|.
%    \begin{macrocode}
\cs_new_protected:Npn \__NPC_add_to_peek_exceptions:Nn #1#2
  {
    \tl_gput_right:cn
      { g_ \cs_to_str:N #1 _exceptions_tl }
      { #2 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\__NPC_remove_from_peek_exceptions:Nn}
%   Remove each the tokens in |#2|
%   from the list of exceptions for the peek command |#1|.
%   The loop is present to allow for more than one token in |#2|.
%    \begin{macrocode}
\cs_new_protected:Npn \__NPC_remove_from_peek_exceptions:Nn #1#2
  {
    \tl_map_inline:nn {#2}
      {
        \tl_gremove_all:cn
          { g_ \cs_to_str:N #1 _exceptions_tl }
          { ##1 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\__NPC_new_peek_command:Nnnn}
%   Declare a token list to hold the exceptions for the command |#1|.
%   Then declare the command |#1|,
%   which simply calls the internal \cs{__NPC_check:NnTF}
%   with the appropriate arguments.
%    \begin{macrocode}
\cs_new_protected:Npn \__NPC_new_peek_command:Nnnn #1#2#3#4
  {
    \tl_new:c { g_ \cs_to_str:N #1 _exceptions_tl }
    \cs_new_protected_nopar:Npn #1
      { \__NPC_check:NnTF #1 {#2} {#3} {#4} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\__NPC_check:NnTF}
%   Peek ahead, ignoring spaces.
%   This is a clever hack:
%   it actually checks whether the next non-space token is a space token.
%   If not (and by definition this will always test false),
%   call \cs{__NPC_check_ii:NnTF}
%   with \cs{l_peek_token} set
%   to the following token in the input stream.
%    \begin{macrocode}
\cs_new_protected:Npn \__NPC_check:NnTF #1#2#3#4
  {
    \peek_catcode_ignore_spaces:NF \c_space_token
      { \__NPC_check_ii:NnTF #1 {#2} {#3} {#4} }
  }
%    \end{macrocode}
%
% (I’d like to define this as scanning for tokens from one list
% while ignoring tokens from another.
% An interface something like
% \begin{quote}
%   \cs{peek_inlist_ignore_auxlist:nnTF} \\
%   |  |\marg{test list} \marg{ignore list} \\
%   |  |\marg{true code} \marg{false code}
% \end{quote}
% would be nice.
% Can anyone help me implement it?)
% \end{macro}
%
% \begin{macro}[internal]{\__NPC_check_ii:NnTF}
%   Given \cs{l_peek_token} set to the following token,
%   compare it against the list of exceptions for |#1|:
%   Loop over the exception list,
%   comparing the character code of each exception to \cs{l_peek_token}.
%   If there is a match,
%   turn on the boolean and break the map.
%   After the loop, leave
%   either the \meta{always} \& \meta{followed} tokens
%   or the \meta{always} \& \meta{not followed} tokens
%   in the input stream,
%   followed by \cs{NPC_\meta{function}_hook:}
%   if it is defined.
%    \begin{macrocode}
\cs_new_protected:Npn \__NPC_check_ii:NnTF #1#2#3#4
  {
    \bool_set_false:N \l__NPC_tmp_bool
    \tl_map_inline:cn { g_ \cs_to_str:N #1 _exceptions_tl }
      {
        \token_if_eq_charcode:NNT ##1 \l_peek_token
          {
            \bool_set_true:N \l__NPC_tmp_bool
            \tl_map_break:
          }
      }
    #2
    \bool_if:NTF \l__NPC_tmp_bool { #3 } { #4 }
    \cs_if_exist:cT { NPC_ \cs_to_str:N #1 _hook: }
      { \use:c { NPC_ \cs_to_str:N #1 _hook: } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Internal variables}
%
% \begin{macro}[internal]{\g_xpeek_exceptions_tl}
%   This token list
%   (actually \cs{g_\meta{function}_exceptions_tl})
%   holds the exceptions associated with a particular command.
% \end{macro}
%
% \begin{macro}[internal]{\l__NPC_tmp_bool}
%   This is used to keep track of whether the \cs{l_peek_token}
%   appears in the exception list or not.
%    \begin{macrocode}
\bool_new:N \l__NPC_tmp_bool
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex
